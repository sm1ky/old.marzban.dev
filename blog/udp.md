

Большинство людей абсолютно не имеют представления о части UDP в протоколах прокси, и в настоящее время многие опытные пользователи и даже разработчики становятся в тупик при столкновении с UDP, что приводит к тому, что большинство проблем, связанных с UDP, остаются нерешенными. Учитывая, что UDP играет всё более и более важную роль, но нет ни одной статьи о UDP в протоколах прокси, была написана эта статья.
Цель этой статьи - изменить текущую ситуацию и позволить всем полностью разобраться в UDP, чтобы использовать Xray-core или другое программное обеспечение для прокси более свободно.

## Простое понимание IP Packet, TCP Connection, пятиэлементных наборов, портов, User Datagram Protocol
Это основные концепции, которые необходимо освоить, на самом деле они очень просты.
IP Packet: отдельные пакеты данных, соответствующие протоколу IP, допускающие потерю пакетов, разрешающие изменение порядка (то есть порядок приема отличается от порядка отправки), относящиеся к ненадежной передаче.
Это не самый нижний уровень, здесь не нужно углубляться, главное - знать его характеристики. Пакеты данных IP не могут напрямую обеспечить надежную передачу, что, конечно, неудобно для приложений, поэтому существует протокол TCP, ориентированный на соединение, который основан на пакетах данных IP, но реализует механизм соединения и надежной передачи, большинство других протоколов могут быть просто размещены на TCP.
Определение TCP-соединения - это "пятиэлементный набор":
1. Идентификатор самого протокола TCP
2. Собственный IP-адрес
3. Используемый собственный порт (Port)
4. IP-адрес другой стороны
5. Порт, используемый другой стороной

После установления TCP-соединения обе стороны могут отправлять прикладные данные с собственных портов на порты другой стороны, это полнодуплексная передача, то есть обе стороны могут одновременно отправлять и принимать данные.
Концепция "порта" всем знакома, она часто появляется вместе с IP, но на самом деле она не относится к протоколу IP (удивительно, не так ли? jpg), она принадлежит к более высоким протоколам TCP, UDP. TCP и UDP реализуют механизм "порта", поэтому порты этих двух протоколов не влияют друг на друга. Протокол, используемый ping, - ICMP, он также основан на пакетах данных IP и похож на TCP, UDP, но у ICMP нет концепции "порта". Кстати, обычные протоколы прокси мог ут проксировать только TCP или добавлять UDP, но не могут проксировать ICMP, поэтому ping невозможен, для этого нужно использовать традиционный VPN.
Теперь настала очередь нашего главного героя выйти на сцену: UDP (User Datagram Protocol)
Хотя UDP, как и TCP, основан на пакетах данных IP, он чрезвычайно прост, прямо полностью наследует характеристики пакетов данных IP:
1. Допускает потерю пакетов
2. Разрешает изменение порядка
3. Очевидно, относится к ненадежной передаче

Вы можете просто понимать это так: протокол UDP просто добавляет механизм портов и проверку к протоколу IP.
Для UDP механизм "соединения" TCP также отсутствует, то есть после получения локального UDP-порта можно напрямую отправлять прикладные данные на любой UDP-порт любого IP без необходимости рукопожатия/установления соединения. Не нужно заботиться о том, получил ли другая сторона данные, другая сторона тоже не скажет вам, получила ли она данные. (Стоит отметить: существует промежуточное состояние connected UDP, это просто определение адреса назначения перед отправкой данных, без реального рукопожатия)
Эти характеристики UDP породили три способа применения:
1. Сосредоточение на эффективности, например, запросы DNS (не требуется предварительное рукопожатие)
2. Сосредоточение на реальном времени, например, прямые трансляции, голосовые данные (допускается потеря пакетов, не требуется ожидание переотправки)
3. Оба эти аспекта + P2P, например, некоторые онлайн-игры, голосовые данные. Обратите внимание, что это полное использование вышеупомянутой особенности UDP, что также является ключевой точкой этой статьи.

Конечно, существует ещё один способ использования UDP: создание новых универсальных надежных транспортных протоколов на его основе, таких как KCP, QUIC. Почему эти новые протоколы не основаны напрямую на протоколе IP, а базируются на UDP? Потому что первое часто требует от операторов на всех уровнях изменения оборудования и систем для поддержки, что, очевидно, не совсем реалистично, поэтому UDP стал более подходящим выбором.

## Так что же такое FullCone и Symmetric?
Эти два термина относятся к поведению NAT, где NAT означает Network Address Translation, то есть преобразование сетевых адресов, которое выполняется вашим домашним маршрутизатором и провайдерами на всех уровнях: преобразование адресов. Широкое распространение NAT обусловлено нехваткой адресов IPv4, а также тем, что он может защищать устройства в локальной сети.
Для TCP поведение NAT не так важно, поскольку TCP представляет собой двусторонний поток, и при каждом установлении TCP-соединения обычно используется новый временный порт, что соответствует новому пятиэлементному набору.
Однако для UDP поведение NAT крайне важно, так как UDP представляет собой пакеты с неопределенным направлением, и очень распространено использование одного и того же локального UDP-порта для отправки пакетов разным целевым двуэлементным наборам.
Двуэлементный набор: IP и Port, любое отличие рассматривается как разные двуэлементные наборы
Так как же маршрутизатор должен перенаправлять UDP-пакеты, когда они достигают его? Это зависит от поведения NAT маршрутизатора.
На самом деле существует множество видов поведения NAT, но давайте рассмотрим наиболее представительные случаи. Для начала представим следующие сценарии:
1. Локальный исходный двуэлементный набор A отправляет несколько пакетов удаленному целевому двуэлементному набору M
2. Локальный исходный двуэлементный набор A отправляет несколько пакетов другому удаленному целевому двуэлементному набору N

Если из-за различия целевых двуэлементных наборов маршрутизатор отображает A->M и A->N как A1->M и A2->N соответственно (обычно используя два разных порта для отправки пакетов) и строго ограничивает источник обратных пакетов, это относится к Symmetric. Не трудно заметить, что в этом случае коммуникация становится похожей на TCP "соединение", что является практикой большинства провайдеров.
Если маршрутизатор смотрит только на исходный двуэлементный набор A и всегда отображает его как свой A1 для отправки пакетов к M и N, это относится к Cone NAT; далее, если A1 получает обратный пакет, маршрутизатор отправляет его обратно к A, не обращая внимания на источник, это относится к FullCone, которое является лучшим уровнем NAT для программного обеспечения прокси и необходимым атрибутом для P2P игр (GTA NAT открыт)
Приведенные выше примеры упрощены, и на практике провайдеры вряд ли предоставят вам публичный IP-адрес напрямую, что означает, что прохождение через несколько уровней NAT и получение Symmetric является нормой. Поч ему же использование протоколов прокси, таких как Shadowsocks или Trojan от Xray-core, позволяет получить FullCone?
Это просто, потому что в этом случае используется публичный IP вашего VPS, который не связан с вашей локальной средой NAT.
Вот почему важно специально настроить брандмауэр VPS: по умолчанию он будет фильтровать источник возвращаемых пакетов, что приведет к тому, что вы получите какой-то вид Restricted Cone, а не FullCone.
Для простых потребностей UDP, таких как запросы DNS, Symmetric также может быть использован. Но для более сложных требований к UDP, таких как различные P2P сценарии, реализация FullCone становится крайне важной, так как приложению необходимо использовать фиксированный порт для отправки пакетов к любой цели и получения пакетов от любой цели без ограничений (по крайней мере, не ошибитесь в определении текущего типа NAT, что будет объяснено далее). Если ваша основная цель - игры, вы можете позволить UDP работать через протокол SS, поскольку он обладает нативными характеристиками UDP.
Здесь стоит отметить, что Xray-core планирует внедрение протоколов, более подходящих для игр.

Теперь перейдем к основной теме - деталям UDP в Xray-core и некоторых прокси-протоколах.
Xray-core поддерживает как FullCone, так и Symmetric режимы, и предоставляет очень широкую поддержку протоколов, что делает его идеальным примером.
Поддержка FullCone реализована для:
- Shadowsocks на входе и выходе
- Trojan на входе и выходе
- Socks на входе и выходе
- Dokodemo-door TPROXY на входе (прозрачный прокси)
- Freedom на выходе, поддержка разрешения доменных имен

Поддержка только Symmetric реализована для:
- VMess, поскольку структура протокола не поддерживает FullCone
- Текущий Mux, также из-за структуры протокола
- VLESS (FullCone в разработке)

Известно, что поддержка UDP в v2ray оставляет желать лучшего, поэтому Xray-core был перестроен с учетом связанных архитектур и кода для входящих и исходящих соединений, а также после многократных тестов и устранения множества деталей и ошибок, была достигнута полная поддержка FullCone (за исключением случаев, когда протокол не поддерживает, для которых предусмотрен адекватный Symmetric, у VMess в Clash есть проблемы).

В заметках к релизу Xray-core содержится много полезной информации:
1. Socks5 и Shadowsocks используют нативный UDP, и их UDP-трафик не идет через нижележащий транспорт.
2. VLESS, Trojan, VMess, Mux используют UDP over TCP и идут через нижележащий транспорт.
3. HTTP на входе и выходе не поддерживает проксирование UDP, Socks до версии 5 также не поддерживает UDP.
4. Здесь FullCone относится к поведению NAT для UDP; при настройке особое внимание уделяется настройке брандмауэра.
5. Для реализации FullCone в цепочке прокси, как правило, все звенья должны поддерживать FullCone.
6. Для реализации FullCone в Docker, сетевой режим связанных контейнеров должен быть Host.


Дополнение: Socks и SS используют нативный UDP, и их UDP-трафик не подвергается специальной обработке при использовании TLS/WSS, если только не включен Mux. UDP-плагины SIP003 для SS также не управляются.

UDP over TCP, сокращенно UoT, важно заметить, что даже если используются mKCP или QUIC в качестве нижележащего транспорта, UoT не будет демонстрировать те же характеристики, что и нативный UDP.

Проблемы, существующие в v2ray-core, здесь разъясняются, чтобы сделать UDP менее загадочным:
1. Архитектурно v2ray-core поддерживает только Symmetric NAT, поэтому любой протокол, используемый в v2ray-core, будет работать только в режиме Symmetric.
2. Обработка UDP в v2ray-core похожа на логику TCP, и невозможно реализовать специфическое для UDP поведение FullCone.
3. При обработке входящих пакетов в выходном модуле Freedom v2ray-core не фильтрует источник в соответствии с принципом Symmetric, что и является основной причиной "мистики".
4. В v2ray-core время неактивности для поддержания отношений маппинга UDP очень короткое, что легко приводит к обрывам потока данных.

По поводу третьего пункта, проще говоря:
1. В нормальной ситуации Symmetric NAT, если A отправил пакеты M, он может получать пакеты только от M, а остальные будут отфильтрованы.
2. Если между ними вставлен v2ray, даже если A не отправлял пакеты N, A всё равно может получать пакеты от N.
3. Главное, что адрес N при этом теряется, и A будет думать, что пакеты от M, что является уникальным источником путаницы.

Такое поведение не ожидается, и в сочетании с некоторыми нестандартными тестовыми серверами это может привести к тому, что v2ray и VMess показывают FullCone, который на самом деле не работает.

В конце июля прошлого года я обсуждал эту проблему в группе разработчиков (нестандартные тестовые серверы, такие как серверы Google, и запутанное поведение UDP в v2ray), после чего обновление NatTypeTester оставило только пять стандартных тестовых серверов и специально проверило исходящие адреса пакетов, что привело к отображению результатов для v2ray как UnsupportedServer.

Кроме того, некоторые приложения Google сначала тестируют тип NAT текущей сети самостоятельно, и если обнаруживается ложный FullCone, это может привести к различным странным проблемам.
Действительно, поведение NAT не ограничивается только FullCone и Symmetric, хотя это два крайних случая. Фактически, поведение NAT определяется двумя аспектами: "маппингом при отправке пакетов" и "фильтрацией при получении пакетов". FullCone является самым открытым в обоих аспектах, в то время как Symmetric является самым строгим.

RFC 3489 определяет четыре классических типа поведения NAT, и v2ray на самом деле не подпадает ни под один из них напрямую, но его поведение наиболее близко к Address and Port-Dependent Mapping с Endpoint-Independent Filtering, что соответствует NAT Type 7 по RFC 5780. Однако v2ray может неправильно обрабатывать источник возвращаемых пакетов.

Эти четыре классических типа включают:
- Full Cone: Любой внешний хост может отправлять пакеты на внутренний IP-адрес и порт, если внутренний хост уже отправил пакеты наружу.
- Address Restricted Cone: Внешний хост может отправлять пакеты на внутренний IP-адрес и порт только если внутренний хост уже отправлял пакеты этому внешнему хосту.
- Port Restricted Cone: Похоже на Address Restricted Cone, но внешний хост должен отправлять пакеты на тот же порт, с которого внутренний хост отправлял пакеты на внешний хост.
- Symmetric: Внутренний хост использует разные маппинги для каждого внешнего хоста и порта, с которыми он общается, и только пакеты, отправленные на адрес

## Как Xray-core реализует протокол прокси с FullCone
на самом деле, принцип довольно прост: он отображает один из ваших локальных UDP-портов на UDP-порт VPS, обеспечивая им одинаковое поведение.

Давайте рассмотрим самый простой сценарий: Socks на входе + Freedom на выходе.
1. Socks на входе получает Socks UDP-пакет от двуэлементного набора A, который содержит оригинальный пейлоад и его исходную цель M, и направляет его в Freedom на выходе.
2. Freedom на выходе использует случайный порт для отправки оригинального пейлоада на его исходную цель M, предположим, что Freedom использует двуэлементный набор A1.
3. Отношение отображения уже установлено, и в течение некоторого времени Socks на входе снова получает прокси-пакет от A, и Freedom продолжит отправлять его на цель, используя A1.
4. Аналогично, если Freedom с A1 получает пакет от N, Socks отправит оригинальный пейлоад и информацию о N обратно к A.

Разумеется, для достижения FullCone вызывающей стороне необходимо правильно использовать протокол прокси Socks, и обычно реализации tun2socks работают без проблем.

Теперь добавим в сценарий Shadowsocks на входе и выходе:
1. Трафик направляется на выход Shadowsocks, который также использует случайный порт для отправки зашифрованного "пейлоада и цели" на серверный вход Shadowsocks.
2. Вход Shadowsocks на сервере получает Shadowsocks UDP-пакет от клиентского выхода Shadowsocks, расшифровывает его, и дальнейший процесс идентичен описанному выше.

Протокол Trojan для UDP работает по аналогичному принципу, но каждый исходный двуэлементный набор соответствует одному TCP-соединению, по которому передается "пейлоад и цель" UDP.

Почему же VMess, который также использует UoT, не может реализовать FullCone?
Основная причина заключается в том, что структура протокола UoT VMess позволяет передать "цель" только в самом начале, а последующие пакеты могут передавать только "пейлоад" без "цели". Сервер будет отправлять все последующие пакеты на исходную "цель". Сервер отправляет пакеты обратно клиенту по той же логике: структура протокола содержит только "пейлоад", и клиент будет считать, что все возвращенные пакеты исходят из первоначальной "цели". Это продолжение проблемы дизайна v2ray, и, конечно, встроенный Mux работает таким же образом. (VLESS также затрагивается, но уже в процессе изменений).

Таким образом, для VMess, Mux и VLESS Xray-core в настоящее время использует маршрутизацию по принципу Symmetric. В противном случае, если использовать режим FullCone, последующие пакеты будут отправляться на адрес первого пакета, что является проблемой Clash с VMess, но это сложно исправить. Кроме того, когда такая проблема существует, VMess может быть ошибочно идентифицирован как FullCone, что неверно.

Принцип прозрачного проксирования UDP через TPROXY заключается в следующем: чтобы использовать Xray-core для реализации FullCone для игровых консолей, обычно требуется Linux-устройство для настройки прозрачного прокси, например, Raspberry Pi.

Почему для прозрачного проксирования UDP предпочтительнее использовать TPROXY, а не REDIRECT?
1. REDIRECT изменяет целевой двуэлементный набор UDP-пакетов, и в этом случае Linux не предоставляет механизм, позволяющий программе-прокси узнать исходный адрес назначения UDP-пакета.
2. TPROXY работает наоборот: он не изменяет UDP-пакеты, и Linux предоставляет простой механизм, позволяющий программе-прокси узнать исходный адрес назначения UDP-пакета.

Когда необходимо отправить пакет обратно, программное обеспечение-прокси сначала создает локальный сокет, имитирующий "исходный двуэлементный набор источника возвращаемого UDP-пакета", и использует этот сокет для отправки пакета обратно. Это и есть принцип, из-за которого может возникнуть ошибка "слишком много открытых файлов". По сравнению с другим программным обеспечением, Xray-core имеет специальные оптимизации для этой ситуации, обеспечивая более элегантное и производительное решение.

Если вы тестируете NAT прозрачного прокси в Windows, обязательно установите текущую сеть как "Частную сеть". Это распространенная ошибка, на которую многие уже наступили, включая меня.

Отдельно стоит упомянуть о QUIC: когда активирован XTLS в Xray-core, трафик, идущий на UDP-порт 443, по умолчанию блокируется (блокировка QUIC), так что приложения не будут использовать QUIC, а будут использовать TLS, благодаря чему XTLS будет действительно работать. На самом деле, QUIC сам по себе не подходит для проксирования, так как он уже включает в себя функции TCP, и использование UoT в этом случае означало бы двойное использование TCP.