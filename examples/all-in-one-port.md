# Все на одном порту

С помощью этого руководства вы можете установить все соединения с вашим сервером (панель, TLS-конфигурация и REALITY) через один порт. Цель - сделать связь с сервером более естественной и обойти ограничения на одном порту.

<figure><img src="../.gitbook/assets/photo_2023-09-23_16-23-38.jpg" alt=""><figcaption></figcaption></figure>

В этом руководстве мы используем инструмент HAProxy для достижения нашей цели. В дальнейшем предполагается, что поддомен панели - `panel.example.com` , поддомен, связанный с TLS-конфигурациями - `sub.example.com`, и используется адрес SNI в конфигурации REALITY - `reality.com`.

Итак, в этом руководстве мы сначала установим и настроим HAProxy, а затем внесем необходимые изменения в конфигурации и панель, чтобы принимать весь трафик на один порт. В конце также приведены некоторые дополнительные замечания.&#x20;

## Установка и настройка HAProxy <a href="#install-haproxy" id="install-haproxy"></a>

{% hint style="info" %}
В этом руководстве мы устанавливаем HAProxy непосредственно на сервере; если вы хотите, вы также можете установить его в контейнере Docker.

Кроме того, если в будущем вы планируете применять более сложные правила, не забудьте установить HAProxy из его основного репозитория, а не из репозиториев Linux.
{% endhint %}

Сначала выполните следующие команды для установки:

```bash
apt update
apt install -y haproxy
```

После установки файл конфигурации HAProxy будет находиться по адресу `/etc/haproxy/haproxy.cfg`.&#x20;

Откройте этот файл с помощью редактора nano для редактирования.

```bash
nano /etc/haproxy/haproxy.cfg
```

Теперь добавьте следующую конфигурацию в конец файла, внесите необходимые изменения в соответствии с инструкциями и сохраните его.

{% code title="haproxy.cfg" %}
```yaml
listen front
 mode tcp
 bind *:443

 tcp-request inspect-delay 5s
 tcp-request content accept if { req_ssl_hello_type 1 }

 use_backend panel if { req.ssl_sni -m end panel.example.com }
 use_backend reality if { req.ssl_sni -m end reality.com }
 default_backend fallback

backend panel
 mode tcp
 server srv1 127.0.0.1:10000

backend fallback
 mode tcp
 server srv1 127.0.0.1:11000

backend reality
 mode tcp
 server srv1 127.0.0.1:12000 send-proxy
```
{% endcode %}

Настройки HAProxy включают один или несколько фронтендов и один или несколько бэкендов. Каждый фронтенд направляет трафик к одному из бэкендов на основе определенных в нем правил. Понимание этих двух принципов в конфигурации HAProxy помогает нам настроить его более эффективно.

При внимательном рассмотрении этой конфигурации вы заметите, что с ее помощью HAProxy прослушивает порт 443 и принимает весь трафик. Затем, в зависимости от SNI (Server Name Indication) полученного трафика, он перенаправляет его на «локальный» порт сервера, что позволяет нам различать разные виды трафика.

{% hint style="info" %}
В этой конфигурации определен бэкенд по умолчанию с использованием `default_backend`, который будет использоваться, если входящий трафик не соответствует ни одному из определенных SNI. Вы можете удалить этот участок кода, чтобы заблокировать трафик, не соответствующий указанным SNI.
{% endhint %}

После замены своих доменов и размещения этой конфигурации в конце указанного файла, выполните следующую команду для перезапуска HAProxy и завершения данного этапа настройки.

```bash
systemctl restart haproxy
```

## Подготовка конфигураций <a href="#config-setup" id="config-setup"></a>

### Подготовка конфигурации REALITY <a href="#setup-reality" id="setup-reality"></a>

Предположим, что вы хотите иметь несколько разных инбаундов для каждого своего узла или несколько разных инбаундов с разными SNI. Если вы просто разместите эти инбаунды один под другим и установите для них одинаковые порты, возникнут проблемы соединения и фактически связь будет невозможна.

Единый порт для конфигураций решает эту проблему. Для этого вам нужно изменить настройки своих конфигураций следующим образом&#x20;

{% hint style="info" %}
обратите внимание на строки 3, 4 и 13
{% endhint %}

{% code title="xray_config.json" lineNumbers="true" fullWidth="false" %}
```json
{
  "tag": "VLESS_TCP_REALITY",
  "listen": "127.0.0.1",
  "port": 12000,
  "protocol": "vless",
  "settings": {
    "clients": [],
    "decryption": "none"
  },
  "streamSettings": {
    "network": "tcp",
    "tcpSettings": {
      "acceptProxyProtocol": true
    },
    "security": "reality",
    "realitySettings": {
      "show": false,
      "dest": "x",
      "xver": 0,
      "serverNames": [
        "reality.com"
      ],
      "privateKey": "x",
      "shortIds": [
        ""
      ]
    }
  },
  "sniffing": {
    "enabled": true,
    "destOverride": [
      "http",
      "tls"
    ]
  }
}
```
{% endcode %}

С этими изменениями ваши инбаунды будут слушать не на 0.0.0.0, а на 127.0.0.1, и вы сможете создавать любое количество инбаундов с разными локальными портами и разделять их в HAProxy на основе sni.

### Подготовка конфигураций с TLS <a href="#setup-tls" id="setup-tls"></a>

Чтобы иметь все типы конфигураций с TLS на одном порту, мы используем fallback&#x20;

Сначала нам понадобится fallback инбаунд. Для этого вы можете использовать следующий пример инбаунда:

```json
{
    "tag": "TROJAN_FALLBACK_INBOUND",
    "port": 11000,
    "protocol": "trojan",
    "settings": {
        "clients": [],
        "decryption": "none",
        "fallbacks": [
            {
                "path": "/lw",
                "dest": "@vless-ws",
                "xver": 2
            },
            {
                "path": "/mw",
                "dest": "@vmess-ws",
                "xver": 2
            },
            {
                "path": "/tw",
                "dest": "@trojan-ws",
                "xver": 2
            }
        ]
    },
    "streamSettings": {
        "network": "tcp",
        "security": "tls",
        "tlsSettings": {
            "serverName": "SERVER_NAME",
            "certificates": [
                {
                    "ocspStapling": 3600,
                    "certificateFile": "/var/lib/marzban/certs/fullchain.pem",
                    "keyFile": "/var/lib/marzban/certs/key.pem"
                }
            ],
            "minVersion": "1.2",
            "cipherSuites": "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
            "alpn": [
                "http/1.1"
            ]
        }
    },
    "sniffing": {
        "enabled": true,
        "destOverride": [
            "http",
            "tls"
        ]
    }
},
```

Для лучшего использования этой возможности полезно понять ее концепцию и работу. fallback работает следующим образом: если входящий трафик соответствует этому инбаунду, он принимается, а если нет, он перенаправляется на другие инбаунды в соответствии с путем (path). Поэтому, после размещения этого инбаунда с fallback, мы определяем несколько других инбаундов, каждый с указанным путем (если у вас уже есть такие инбаунды, достаточно изменить значение listen на предопределенные значения (`@vless-ws`, `@vmess-ws` и `@trojan-ws`) и добавить их путь в инбаунд с fallback.

Итак, инбаунд с fallback отправляет трафик на другие инбаунды в зависимости от пути каждого из входящих трафиков:

```
path = /lw     ->    listen: "@vless-ws"
path = /mw     ->    listen: "@vmess-ws"
path = /tw     ->    listen: "@trojan-ws"
```

Итак, в соответствии с приведенным выше примером, вам просто нужно сделать разделы listen и path ваших конфигураций входящих соответствующими конфигурации fallback, чтобы все конфигурации выполнялись на одном порту.

{% hint style="info" %}
Использование fallback увеличивает нагрузку на сервер. Вы можете установить разные поддомены для каждой из ваших конфигураций и использовать один и тот же HAProxy без необходимости перехода к однопортовым конфигурациям с TLS.
{% endhint %}

{% hint style="warning" %}
Обратите внимание, что во входящих, у которых значение listen имеет форму @xxx и используется в fallback, вы должны удалить строку, относящуюся к порту.
{% endhint %}

Теперь, если вы использовали этот метод для объединения ваших входящих с помощью fallback, откройте файл `.env` и установите следующую переменную равной вашему тегу входящего fallback:

```
XRAY_FALLBACKS_INBOUND_TAG = "TROJAN_FALLBACK_INBOUND"
```

## Подготовка панели управления <a href="#configure-app" id="configure-app"></a>

Как уже упоминалось, нашей целью является наличие всех коммуникаций, включая панель управления (ссылку на подписку), на одном порту.

Ранее мы настроили параметры, относящиеся к панели управления, в конфигурации HAProxy, и в этом этапе достаточно сделать порт, на котором слушает панель, согласованным с HAProxy. Для этого вам просто нужно внести изменения в файл `.env` и установить переменные, указанные ниже, равными определенному значению (или тому, что вы ввели в HAProxy):

```
UVICORN_HOST = "127.0.0.1"
UVICORN_PORT = 10000
```

Теперь перезапустите Marzban:

```bash
marzban restart
```

## Подготовка хоста <a href="#setup-host" id="setup-host"></a>

Поскольку порт, указанный в inbound, является локальным портом, и фактически весь трафик идет на ваш сервер через порт 443, необходимо изменить порт на 443 в разделе хоста для созданных вами конфигураций, иначе порты по умолчанию устанавливаются для локальных конфигураций.

## Дополнительные замечания <a href="#etc" id="etc"></a>

{% hint style="warning" %}
Настройки, связанные с HAProxy, должны быть выполнены на всех узлах сервера, или вы можете определить отдельные входящие для некоторых узлов сервера и прослушивать их напрямую на 0.0.0.0
{% endhint %}

{% hint style="danger" %}
вы должны добавить фразу "send-proxy" в конце каждого бэкенда HAProxy, а также установить значение "acceptProxyProtocol": true в вашей входящей конфигурации, согласно приведенному выше примеру для REALITY.&#x20;

Если конфигурация имеет "send-proxy", но не имеет "acceptProxyProtocol": true, соединение не будет установлено.
{% endhint %}

